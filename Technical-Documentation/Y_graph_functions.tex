\begin{table}
  \small
  \centering
  \begin{tabular}{| m{0.35\textwidth} | m{0.6\textwidth} |}
    \hline
    \shortstack[l]{
      \Code{NodeList getNodes()}\\
      \Code{NodeSet getNodeSet()}
    }
    &
    returns a list or set of the nodes of the graph; see
    Section~\ref{sec:datastructures} for more information about the return types
    \\ \hline
    \shortstack[l]{
      \Code{EdgeList getEdges()}\\
      \Code{EdgeSet getEdgeSet()}
    }
    &
    returns a list of edges of the graph; return types are analogous to those
    for nodes
    \\ \hline
    \Code{for\_nodes(v) \{
      \emph{code block}
      \}}
    &
    \shortstack[l]{
      equivalent to
      \Code{for ( Node v : getNodes() ) \{ \emph{code block} \}};\\
      the statements in \emph{code block} are executed for each node \Code{v}
    }
    \\ \hline
    \Code{for\_edges(e)  \{ \emph{code block} \}}
    &
    analogous to \Code{for\_nodes} with \Code{getEdges()} in place of \Code{getNodes()}
    \\ \hline
    \Code{Integer numberOfNodes()}
    &
    returns the number of nodes
    \\ \hline
    \Code{Integer numberOfEdges()}
    &
    returns the number of edges
    \\ \hline
    \Code{int~id(Node~v)}, \Code{int~id(Edge e)}
    &
    returns the unique identifier of \Code{v} or \Code{e}
    \\ \hline
    \Code{int~nodeIds()}, \Code{int~edgeIds()}
    &
    returns the largest node/edge identifier plus one;
    useful when an array is to be indexed using node/edge identifiers,
    since these are not necessarily contiguous
    \\ \hline
    \Code{source(Edge e)}, \Code{target(Edge e)}
    &
    returns the source/target of edge \Code{e}, sometimes called the (arrow)
    tail/head or source/destination
    \\ \hline
    \shortstack[l]{
      \Code{Integer degree(Node v)}\\
      \Code{Integer indegree(Node v)}\\
      \Code{Integer outdegree(Node v)}
    }
    &
    the number of edges incident on \Code{v}, total, incoming and outgoing;
    if the graph is undirected, the outdegree is the same as the degree
    \\ \hline
    \shortstack[l]{
      \Code{EdgeList edges(Node v)}\\
      \Code{EdgeList inEdges(Node v)}\\
      \Code{EdgeList outEdges(Node v)}
    }
    &
    returns a list of \Code{v}'s
    incident, incoming or outgoing edges, respectively;
    outgoing edges are the same as incident edges if the graph is undirected 
    \\ \hline
    \shortstack[l]{
      \Code{Node otherEnd(Edge e, Node v)}\\
      \Code{Node otherEnd(Node v, Edge e)}
    }
    &
    returns the node opposite \Code{v} on edge \Code{e};
    if \Code{v} is the source \Code{otherEnd} returns the target and
    vice-versa
    \\ \hline
    \Code{NodeList neighbors(Node v)}
    &
    returns a list of nodes adjacent to \Code{v}
    \\ \hline
    \shortstack[l]{
      \Code{for\_adjacent(v, e, w) \{ \emph{code block} \}} \\
      \Code{for\_incoming(v, e, w) \{ \emph{code block} \}} \\ 
      \Code{for\_outgoing(v, e, w) \{ \emph{code block} \}}
    }
    &
    \Code{for\_adjacent} executes the code block for each edge \Code{e}
    incident on \Code{v}, where \Code{w} is \Code{otherEnd(e,v)};
    \Code{v} must already be declared but \Code{e} and \Code{w} are
    declared by the macro;
    the other two are analogous for incoming and outgoing edges 
    \\ \hline
    \Code{getStartNode()}
    &
    returns the first node in the list of nodes, typically the one with smallest id;
    used by algorithms that require a start node
    \\ \hline
    \Code{isDirected()}
    &
    returns \Code{true} if the graph is directed
    \\ \hline
    \Code{setDirected(boolean directed)}
    &
    makes the graph directed or undirected depending on whether \texttt{directed}
    is true or false, respectively
    \\ \hline
    \shortstack[l]{
      \Code{Node addNode()}\\
      \Code{Node addNode(Integer x, Integer y)}
    }
    &
    returns a new node and adds it to the list of nodes;
    the id is the smallest integer not currently in use as an id;
    attributes such as weight, label and position are absent and must be set explicitly
    by appropriate method calls;
    the second version puts the node at position \Code{(x,y)},
    where \Code{x} and \Code{y} are pixel coordinates.
    \\ \hline
    \shortstack[l]{
      \Code{addEdge(Node source, Node target)}\\
      \Code{addEdge(int sourceId, int targetId)}
    }
    &
    adds an edge from the source to
    the target (source and target are interchangeable when graph is undirected);
    the second variation specifies id's of the nodes to be connected;
    as in the case of adding a node, the edge is added to the list of edges and
    its weight and label are absent
    \\ \hline
    \Code{deleteNode(Node v)}
    &
    removes node \Code{v} and its incident edges from the graph
    \\ \hline
    \Code{deleteEdge(Edge e)}
    &
    removes edge \Code{e} from the graph
    \\ \hline
  \end{tabular}
  \caption{Functions and macros that apply to the structure of a graph.}
  \label{tab:graph_functions}
\end{table}

% [Last modified: 2017 01 17 at 19:27:02 GMT]

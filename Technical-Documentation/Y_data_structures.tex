\begin{table}
  \small
  \textbf{NodeList and EdgeList:} lists of nodes or edges, respectively.
  We use \emph{list} as shorthand for either \Code{NodeList} or
  \Code{EdgeList}, \emph{type} for either \Code{Node} or \Code{Edge}
  and \emph{element} for \Code{Node v} or \Code{Edge e}.
  
  \medskip
  \begin{tabular}{| m{0.35\textwidth} | m{0.6\textwidth} |}
    \multicolumn{2}{c}{\textbf{Initialization}}
    \\
    \hline
    \Code{\emph{list} $L$ = new \emph{type}List();}
    & creates an empty list $L$
    \\
    \hline
    \multicolumn{2}{c}{\textbf{Other methods}}
    \\
    \hline
    \Code{\emph{type} first(\emph{list} $L$)}
    &
    returns the first element of $L$
    \\ \hline
    \Code{\emph{type} get(int $i$, \emph{list} $L$)}
    &
    returns the $i$-th element of $L$; indexing is 0-based, so
    \Code{get(0,$L$)} is the same as \Code{first($L$)}
    \\ \hline
    \Code{add(\emph{element} $x$, \emph{list} $L$)}
    &
    adds the element $x$
    to the end of list $L$; along with \Code{first}
    we get the effect of a queue
    \\ \hline
    \Code{remove(\emph{element} $x$, \emph{list} $L$)}
    &
    removes the first occurrence of $x$ from $L$
    \\ \hline
  \end{tabular}  
  
  \bigskip
  \textbf{NodeQueue and EdgeQueue:} queues of nodes or edges, respectively.
  Same conventions as for lists.

  \medskip
  \begin{tabular}{| m{0.35\textwidth} | m{0.6\textwidth} |}
    \hline
      \Code{void~enqueue(\emph{element})}
    &
    adds the element to the rear of the queue
    \\ \hline
    \Code{\emph{type} dequeue()}
    &
    returns and removes the element at the front of the queue;
    returns \Code{null} if the queue is empty
    \\ \hline
    \Code{\emph{type} remove()}
    &
    returns and removes the element at the front of the queue;
    throws an exception if the queue is empty
    \\ \hline
    \Code{\emph{type}~element()}
    &
    returns the element at the front of the queue
    without removing it;
    throws an exception if the queue is empty
    \\ \hline
    \Code{\emph{type} peek()}
    &
    returns the element at the front of the queue
    without removing it;
    returns \Code{null} if the queue is empty
    \\ \hline
    \Code{size()}
    &
    returns the number of elements in the queue
    \\ \hline
    \Code{isEmpty()}
    &
    returns \Code{true} if the queue is empty 
    \\ \hline
  \end{tabular}

  \bigskip
  \textbf{NodeStack and EdgeStack:} stacks of nodes or edges, respectively.

  \medskip
  \begin{tabular}{| m{0.35\textwidth} | m{0.6\textwidth} |}
    \hline
      \Code{void~push(\emph{element})}
    &
    adds the element to the top of the stack
    \\ \hline
    \Code{\emph{type}~pop()}
    &
    returns and removes the element at the top of the stack;
    throws an exception if the stack is empty
    \\ \hline
    \Code{\emph{type} peek()}
    &
    returns the element at the top of the stack
    without removing it;
    returns null if the stack is empty
    \\ \hline
    \Code{size()}, \Code{isEmpty()}
    &
    analogous to the corresponding queue methods
    \\ \hline
  \end{tabular}

  \bigskip
  \textbf{NodeSet and EdgeSet:} sets of nodes or edges, respectively.

  \medskip
  \begin{tabular}{| m{0.35\textwidth} | m{0.6\textwidth} |}
    \hline
    \Code{boolean~add(\emph{element})}
    &
    adds the element to the set;
    returns true if the element was a new addition, false otherwise
    \\ \hline
    \Code{boolean~remove(\emph{element})}
    &
    removes the element
    returns \Code{true} if the element was present,
    \Code{false} otherwise
    \\ \hline
    \Code{boolean~contains(\emph{element})}
    &
    returns true if the element is in the set
    \\ \hline
    \Code{size()}, \Code{isEmpty()}
    &
    analogous to the corresponding methods for other data structures
    \\ \hline
  \end{tabular}

  \caption{Built-in data structures and their methods.
     These methods use object-oriented syntax:
$\langle$\emph{structure}$\rangle$.$\langle$\emph{method}$\rangle$($\langle$\emph{arguments}$\rangle$)
    and are created using, e.g.,
    \Code{NodeQueue~Q~=~new~NodeQueue();} the \Code{new} operator in Java.
  }
  \label{tab:data_structures}
\end{table}

% [Last modified: 2017 01 13 at 13:48:06 GMT]

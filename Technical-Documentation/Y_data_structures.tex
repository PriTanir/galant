\begin{table}
  \textbf{NodeList and EdgeList:} lists of nodes or edges, respectively.
  We use \emph{list} as shorthand for either \Code{NodeList} or
  \Code{EdgeList}, \emph{type} for either \Code{Node} or \Code{Edge}
  and \emph{element} for \Code{Node v} or \Code{Edge e}.
  
  \medskip
  \begin{tabular}{| m{0.3\textwidth} | m{0.65\textwidth} |}
    \hline
    \Code{\emph{type} first(\emph{list} $L$)}
    &
    returns the first element of $L$
    \\ \hline
    \Code{\emph{type} top(\emph{list} $L$)}
    &
    returns the first element of $L$ (top of stack)
    \\ \hline
    \Code{add(\emph{element} $g$, \emph{list} $L$)}
    &
    adds the element $g$
    to the end of list $L$
    \\ \hline
    \Code{push(\emph{element}, \emph{list} $L$)}
    &
    adds the element $g$
    to the front of list $L$ (pushes on stack)
    \\ \hline
    \Code{\emph{type} pop(\emph{list} $L$)}
    &
    removes and returns the first element of $L$
    \\ \hline
    \Code{remove(\emph{element}, \emph{list} $L$)}
    &
    removes the first occurrence of $g$ from $L$
    \\ \hline
    \Code{size(\emph{list} $L$)}
    &
    returns the number of elements in $L$
    \\ \hline
    \Code{empty(\emph{list} $L$)}
    &
    returns \Code{true} if $L$ is empty
    \\ \hline
  \end{tabular}  
  
  \bigskip
  \textbf{NodeQueue and EdgeQueue:} queues of nodes or edges, respectively.
  Same conventions as for lists, except we use \emph{queue} in place of
  \emph{list}.

  \medskip
  \begin{tabular}{| m{0.3\textwidth} | m{0.65\textwidth} |}
    \hline
      \Code{void~put(\emph{element}, \emph{queue})}
    &
    adds the element to the rear of the queue; throws an exception if the element is
    \Code{null}
    \\ \hline
    \Code{\emph{type} get(\emph{queue})}
    &
    returns and removes the element at the front of the queue;
    throws an exception if the queue is empty
    \\ \hline
    \Code{\emph{type}~front(\emph{queue})}
    &
    returns the element at the front of the queue
    without removing it;
    throws an exception if the queue is empty
    \\ \hline
  \end{tabular}

   \bigskip
  \textbf{NodeSet and EdgeSet:} sets of nodes or edges, respectively; same
  conventions as for lists, except for the use of \emph{set}.
  The first two table entries give natural syntax for set membership.

  \medskip
  \begin{tabular}{| m{0.3\textwidth} | m{0.65\textwidth} |}
    \hline
    \Code{boolean~\emph{set}.contains($g$)}
    &
    returns true if $g$ is an element of the set, where $g$ is a node or
    edge, as appropriate; if $g$ has the wrong type, this method will simply
    return \Code{false}
    \\
    \hline
    \Code{boolean~$g$.in(\emph{set})}
    &
    returns true if $g$ is an element of the set, where $g$ is a node or
    edge, as appropriate; here, if $g$ has the wrong type, the error will be
    caught by the compiler
    \\ \hline
    \Code{union($s_1$, $s_2$)}
    &
    returns the union of $s_1$ and $s_2$; here $s_1$, $s_2$ and the return
    value are all of type \Code{NodeSet} or \Code{EdgeSet} 
    \\ \hline
    \Code{intersection($s_1$, $s_2$)}
    &
    returns the intersection of $s_1$ and $s_2$
    \\ \hline
    \Code{difference($s_1$, $s_2$)}
    &
    returns the set difference $s_1 - s_2$, elements that are in $s_1$ but
    not in $s_2$
    \\ \hline
    \Code{symmetricDifference($s_1$, $s_2$)}
    &
    returns the set symmetric difference of $s_1$ and $s_2$, i.e., the union
    of $s_1 - s_2$ and $s_2 - s_1$
    \\ \hline
  \end{tabular}

  \caption{Operations on Galant data structures (procedural versions).}
  \label{tab:data_structures}
\end{table}

% [Last modified: 2017 01 16 at 23:42:47 GMT]

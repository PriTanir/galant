Animation programmers can write algorithms in notation that resembles
textbook pseudocode
in files that have a \Code{.alg} extension.
The animation examples have used procedural syntax for function calls, as in, for example,
\Code{setWeight(v,0)}.
Java (object oriented) syntax can also be used: \Code{v.setWeight(0)}.
A key advantage of Galant is that a seasoned Java programmer can
not only use the Java syntax but can also augment Galant algorithms with
arbitrary Java classes defined externally, using \Code{import} statements.
All Galant code is effectively Java, either natively, or via macro preprocessing.

The text panel provides a crude editor for algorithms (as well as GraphML
descriptions of graphs);
its limited capabilities make it useful primarily for fine tuning and error correction.
The animator should use a program editor such as \Code{Emacs} or
\Code{Notepad++} (in Java mode) to edit algorithms offline,
not a major inconvenience -- it is easy to reload algorithms when they are modified
without exiting Galant.
The Galant editor is, however, useful in that it provides syntax highlighting of Galant
functions and macros.

The source code for an algorithm begins with any number (including none)
of global variable declarations and function definitions.
The animator can import code from other sources using appropriate
\Code{import} statements; these must occur at the very beginning.
The code for the algorithm itself follows, starting with the keyword
\textsf{algorithm}.
A \emph{code block}
is a sequence of statements, each terminated by a semicolon, just as in
Java.
An animation program has the form
\begin{quote}
  \emph{global variable declarations}\\
  \\
  \emph{function definitions}\\
  \\
  \Code{algorithm \{}\\
  \hspace*{2em}\emph{code block}\\
  \Code{\}}
\end{quote}

Declarations of global variables are also like those of Java:\\
\hspace*{1em}\emph{type} \emph{variable\_name}\texttt{;}\\
or\\
\hspace*{1em}\emph{type} \texttt{[]} \emph{variable\_name}\texttt{;}\\
to declare an array of the given type.
All variables must be initialized either within a function definition or
in the algorithm.
Unlike Java variables, they cannot be initialized in the statement that
declares them.\footnote{This restriction applies to global variables
  only. Variables local to function definitions or to the algorithm can be
  initialized in-line, just as in Java.
}
The Java incantation\\
\hspace*{1em}\emph{type} \emph{variable\_name}
\texttt{= new} \emph{type}\texttt{[} \emph{size} \texttt{]}\\
is used to initialize an array with \emph{size} elements initialized to \textsf{null}
or 0.
Arrays use 0-based indexing: the largest index is $\mathit{size} - 1$.
Detailed
information about function declarations is in Section~\ref{sec:functions}
below.

Central to the Galant API is the \Code{Graph} object: currently all other
parts of the API refer to it.
The components of a graph are declared to be of type \Code{Node} or
\Code{Edge} and can be accessed/modified via a variety of
functions/methods.
When an observer or explorer interacts with the animation they move either
forward or backward one step at a time.
All aspects of the graph API therefore refer to the current \emph{state of
  the graph}, the set of states behaving as a stack.
API calls that change the state of a node or an edge automatically
generate a next step,
but the programmer can override this using a \Code{beginStep()} and
\Code{endStep()} pair. For example, the beginning of our implementation of
Dijkstra's algorithm looks like

\begin{center}
\begin{minipage}{0.5\textwidth}
\begin{verbatim}
beginStep();
for_nodes(node) {
    setWeight(node, INFINITY);
    nodePQ.add(node);
}
endStep();
\end{verbatim}
\end{minipage}
\end{center}

Without the \Code{beginStep}/\Code{endStep}
override, this initialization would require the observer to click
through multiple steps (one for each node) before getting to the interesting
part of the animation.
For convenience the function \Code{step()} is a synomym for \Code{endStep();~beginStep()}.
If a step takes longer than \Timeout\ seconds, the program is terminated
under the presumption that there may be an infinite loop.

\input{Y_graph_functions}

\input{Y_utility_functions}

Functions and macros for the graph as a whole are shown in Table~\ref{tab:graph_functions}, while Table~\ref{tab:utility_functions} lists some algorithm functions not related to any aspect of a graph.

\emph{\textbf{Note:} The functions/methods provided by Galant may have multiple synonyms for
convenience and backward compatibility. A full list of methods and functions
is given in \Code{Algorithm.java} in the subdirectory
\Code{src/edu/ncsu/csc/Galant/algorithm}.}

The nodes and edges, of type \textsf{Node} and \textsf{Edge}, respectively,
are subtypes/extensions of \textsf{GraphElement}.
Arbitrary attributes can be assigned to each graph element. In the GraphML file
these show up as, for example,\\
\hspace*{3em}
\textsf{
$<$node \emph{attribute\_1}="\emph{value\_1}" ... \emph{attribute\_k}="\emph{value\_k}" /$>$
}

Each node and edge has a unique integer id.
The id's are assigned consecutively as nodes/edges are created;
they may not be altered.
The id of a node or edge can be accessed via the \Code{id()} function.
Often, as is the case with the depth-first search algorithm, it makes sense to use
arrays indexed by node or edge id's.
Since graphs may be generated externally and/or have undergone deletions of nodes or
edges, the id's are not always contiguous.
The functions \Code{nodeIds()} and \Code{edgeIds()} return the size of an array
large enough to accommodate the appropriate id's as indexes. So code such as

\begin{minipage}{0.8\textwidth}
\begin{verbatim}
        Integer myArray[] = new Integer[nodeIds()];
        for_nodes(v) { myArray[id(v)] = 1; }
\end{verbatim}
\end{minipage}

is immune to array out of bounds errors.

\subsection{Node and edge methods}

Nodes and edges have `getters' and `setters' for
a variety of attributes, i.e.,
\\
\Code{set}$a$\Code{($\langle a's$ type$\rangle$ x)}
\\
and
\\
$\langle a's$ type$\rangle$ \Code{get}$a$\Code{()},
where $a$ is the name of an attribute such as
\Code{Color},
\Code{Label} or \Code{Weight}.
A more convenient way to access these standard attributes omits the prefix \Code{get}
and uses procedural syntax:
\Code{color(}$x$\Code{)} is a synonym for $x$\Code{.getColor()}, for example.
Procedural syntax for the setters is also available:
\Code{setColor(}$x$,$c$\Code{)} is a synonym for $x$.\Code{setColor(}$c$\Code{)}.
In the special cases of color and label it is possible to omit the \Code{set}
(since it reads naturally):
\Code{color($x$,$c$)} instead of
\Code{setColor($x$,$c$)};
and
\Code{label($x$,$c$)} instead of
\Code{setLabel($x$,$c$)}.

\subsubsection{Logical attributes: functions and macros}

\textbf{Nodes.} From a node's point of view we would like information about
 the adjacent nodes and incident edges.  The relevant \emph{methods} require
 the use of Java generics, but macros are provided to simplify graph API
 access. The macros (which are borrowed from their equivalents in GDR) are:

\begin{itemize}

\item
\Code{for\_adjacent(x, e, y)\{ \emph{code block} \}}
executes the statements in the code block for each edge incident on \verb$x$.
The statements can refer to \verb$x$, or \verb$e$, the current incident edge,
or \verb$y$, the other endpoint of \verb$e$.
The macro assumes that \Code{x} has already been declared as \Code{Node}
but \Code{e} and \Code{y} are declared automatically.

\item
\Code{for\_outgoing(Node x, Edge e, Node y)\{ \emph{code block} \}}\\
behaves like \Code{for\_adjacent} except that, when the graph is directed,
it iterates only over the edges whose source is \verb$x$ (it still iterates over all the edges when the graph is undirected). 

\item
\Code{for\_incoming(Node x, Edge e, Node y)\{ \emph{code block} \}}\\
behaves like \Code{for\_adjacent} except that, when the graph is directed,
it iterates only over the edges whose sink is \verb$x$ (it still iterates over all the edges when the graph is undirected). 

\end{itemize}

The actual API methods hiding behind these macros are (these are Node methods):

\begin{itemize}
\item
\Code{List$\langle$Edge$\rangle$~edges($v$)} returns a list of all edges
incident to $v$, both incoming and outgoing.
\item
\Code{List$\langle$Edge$\rangle$~outgoingEdges($v$)} returns a list of edges
directed away from $v$ (all incident edges if the graph is undirected).
\item
\Code{List$\langle$Edge$\rangle$~incomingEdges($v$)} returns a list of edges
directed toward $v$ (all incident edges if the graph is undirected).
\item
\Code{Node~otherEnd($e$, $v$)} returns the endpoint, other than $v$, of $e$.
\end{itemize}

The following are node functions with procedural syntax.

\begin{itemize}
\item \Code{degree(v)}, \Code{indegree(v)} and \Code{outdegree(v)} return the appropriate
integers.
\item \Code{otherEnd(v, e)}, where \Code{v} is a node and \Code{e} is an edge
returns node \Code{w} such that \Code{e} connects \Code{v} and \Code{w};
the programmer can also say \Code{otherEnd(e, v)} in case she forgets the order
of the arguments.
\item \Code{neighbors(v)} returns a list of the nodes adjacent to node \Code{v}.
\end{itemize}

\bigskip
\textbf{Edges.}
The logical attributes of an edge $e$ are its source and target (destination)
accessed using \Code{source($e$)} and \Code{target($e$)}, respectively.

\bigskip
\textbf{Graph Elements.}
Nodes and edges both have a mechanism for setting (and getting)
arbitrary attributes of type Integer, String, and Double.
the relevant methods are listed below.
Note that the type can be implicit for the setters -- the compiler can figure
that out, but needs to be explicit for the getters -- in Java, two methods
that differ only in their return type are indistinguishable.
In each case $g$ stands for a graph element (node or edge).
\begin{itemize}
  \item \Code{set($g$, String \emph{attribute}, $\langle \mathit{type} \rangle$ \emph{value})},
    where \emph{type} can be \Code{String}, \Code{Boolean}, \Code{Integer},
    or \Code{Double}.
  \item \Code{set($g$, String \emph{attribute})}; the attribute is assumed to
    be Boolean, the value is set to \Code{true}.
  \item \Code{String getString($g$, String \emph{attribute})}
  \item \Code{Boolean getBoolean($g$, String \emph{attribute})}
    \item \Code{Boolean is(String \emph{attribute})}, a synonym for
      \Code{getBoolean} 
  \item \Code{Integer getInteger($g$, String \emph{attribute})}
  \item \Code{Double getDouble($g$, String \emph{attribute})}
\end{itemize}
An object oriented syntax can also be used -- this is especially natural in
case of \Code{is}, as in \Code{v.is("inTree")} -- see \Code{boruvka} in the
\Code{Algorithms} directory.
These are useful when an algorithm requires arbitrary information to be
associated with nodes and/or edges.
The user-defined attributes may differ from one node or edge to the next.
For example, some nodes may have a \Code{depth} attribute while others do not.

\subsubsection{Geometric attributes}

Currently, the only geometric attributes are the positions of the
nodes. 
Unlike GDR, the edges in Galant
are all straight lines and the positions of their labels are fixed.
The relevant methods for nodes -- using procedural syntax -- are
\Code{int~getX(Node)}, \Code{int~getY(Node)}
and \Code{Point~getPosition(Node)}
for the getters. To set a position,
one should use\\
\hspace*{2em}\Code{setPosition(Node,Point)}\\
or\\
\hspace*{2em}\Code{setPosition(Node,int,int)}.\\
Once a node has an established position, it is possible to change
one coordinate at a time using \Code{setX(Node,int)} or \Code{setY(Node,int)}.
Object-oriented variants of all of these, e.g.,
\Code{v.setX(100)}, are also available.

The user is allowed to move nodes during algorithm execution
and the resulting positions persist after execution terminates.
Node position is the only attribute that can be "edited" at runtime.
For some animations, however, such as sorting,
the animation itself needs to move
nodes.
To avoid potential conflicts between position changes inflicted by the user
and those desired by the animation.
the function \Code{movesNodes()}, called at the beginning of an algorithm
will prevent the user from moving nodes.

\subsubsection{Display attributes} \label{sec:display_attributes}

Each node and edge has
both a (double) weight and a label.
The weight
is also a logical
attribute in that
it is used implicitly as a
key for
sorting and priority queues.
The label is simply text and may be interpreted however the programmer
chooses.
The conversion functions \Code{integer(String)}
and \Code{real(String)}
-- see Table~\ref{tab:utility_functions}
-- provide a convenient mechanism for treating labels as objects of class
\Code{Integer} or \Code{Double}, respectively.
The second argument of \Code{label} (or single argument of the
object-oriented \Code{setLabel})
is not the expected \Code{String}
but \Code{Object};
any type of object that has a Java \Code{toString} method will work
-- numbers have to be of type \Code{Integer} or \Code{Double}
rather than \Code{int} or \Code{double} since the latter are not objects
in Java.\footnote{
  Galant functions return objects, \Code{Integer} or \Code{Double}, when
  return values are numbers for this reason.
}
Thus, conversion between string labels and numbers works both ways.

Aside from the setters and getters: \Code{setWeight(double)},
\mbox{\Code{Double getWeight()}}, \Code{setLabel(Object)}
and \mbox{\Code{String getLabel()}}, the programmer can also
manipulate and test for the absence of weights/labels using
\Code{clearWeight()} and \Code{boolean~hasWeight()},
and the corresponding methods for labels.
The procedural variants in this case are
\begin{itemize}
  \item \Code{setWeight(Node,double)},
  \item \mbox{\Code{Double getWeight(Node)}} or the more natural
    \mbox{\Code{Double weight(Node)}},
   \item \Code{setLabel(Node,Object)} or the more natural
     \Code{label(Node,Object)},
   \item \Code{getLabel(Node)} or the more natural
     \mbox{\Code{String label(Node)}}
\end{itemize}

Nodes can either be plain, highlighted (selected), marked (visited) or both highlighted and
marked.
Being highlighted alters the
the boundary (color and thickness) of a node (as controlled by the
implementation), while being marked affects the fill color.
Edges can be plain or selected, with thickness and color modified in the
latter case.

The relevant methods are
(here \Code{Element} refers to either a \Code{Node} or an \Code{Edge}):
\begin{itemize}
\item \Code{highlight(Element)}, \Code{unhighlight(Element)}
  and \Code{Boolean~isHighlighted(Element)}
\item correspondingly, \Code{setSelected(true)}, \Code{setSelected(false)},
and \Code{boolean~isSelected()}
\item \Code{mark(Node)}, \Code{unmark(Node)}
  and \Code{Boolean~isMarked(Node)},
  equivalently \Code{Boolean~marked(Node)}.
\end{itemize}

\begin{table}
  \centering
  \begin{tabular}{{| l @{~=~} l |}}
    \hline
    \texttt{RED} & \texttt{"\#ff0000"} \\ \hline
    \texttt{BLUE} & \texttt{"\#00ff00"} \\ \hline
    \texttt{GREEN} & \texttt{"\#0000ff"} \\ \hline
    \texttt{YELLOW} & \texttt{"\#ffff00"} \\ \hline
    \texttt{MAGENTA} & \texttt{"\#ff00ff" } \\ \hline
    \texttt{CYAN} & \texttt{"\#00ffff"} \\ \hline
    \texttt{TEAL} & \texttt{"\#009999"} \\ \hline
    \texttt{VIOLET} & \texttt{"\#9900cc"} \\ \hline
    \texttt{ORANGE} & \texttt{"\#ff8000"} \\ \hline
    \texttt{GRAY} & \texttt{"\#808080"} \\ \hline
    \texttt{BLACK} & \texttt{"\#000000"} \\ \hline
    \texttt{WHITE} & \texttt{"\#ffffff"} \\ \hline
  \end{tabular}
  \caption{Predefined color constants.}
  \label{tab:colors}
\end{table}

Although the specific colors for displaying the outlines of nodes
or the lines representing edges are
predetermined for plain
and highlighted nodes/edges,
the animation implementation can modify these colors,
thus allowing for many different kinds of highlighting.
The \Code{getColor} and \Code{setColor} methods
and their procedural variants have \Code{String} arguments
in the RGB format \texttt{\#RRGGBB}; for example,
the string \texttt{\#0000ff} is blue.
Here, as in the case of label, \Code{color($g$)} and \Code{color($g$,$c$)}
can be used in place of \Code{getColor($g$)} and \Code{setColor($g$,$c$)},
respectively.
Galant defines several color constants for convenience -- 
these are listed in Table~\ref{tab:colors} -- so one can say, e.g.,
\Code{color($g$,TEAL)} instead of \Code{color($g$,"\#009999")}.

Note: In the graph display \emph{highlighting takes precedence over color};
if a node is highlighted, its color is ignored and the default highlight
color is used.

Special handling is required when any attribute is nonexistent or has a
\Code{null} value -- these two are equivalent.
When displayed in the graph window, nonexistent labels and weights simply do
not show up while nonexistent colors are rendered as thin black lines
(thickness determined by user preference).
In an animation program, however, nonexistent attributes are handled
differently.
\begin{itemize}
\item \Code{color()} returns null as expected
\item all functions returning Boolean values, such as \Code{highlighted()},
  \Code{marked()} and those for attributes defined by the animator, return
  \Code{false}
\item \Code{label()} returns an empty string; this ensures that it is always
  safe to use a label in an expression calling for a string
\item \Code{weight()} throws an exception; there is no obvious default
  weight; a program can test for the presence/absence of a weight using the
  \Code{hasWeight()} or \Code{hasNoWeight()} methods
\end{itemize}

Of the attributes listed above, weight, label, color and position can be
accessed and modified by the user as well as the program.
In all cases (of display attributes -- recall that node positions are an
exception), modifications during runtime are ephemeral
-- the graph returns to its original, pre-execution, state after running the
animation.
The user can save the mid-execution state of the graph:
select the \Code{Export} option on the file menu of the
\emph{graph} window.

\input{Y_graph_element_functions}

A summary of functions relevant to node and edge attributes (their procedural versions)
is given in Table~\ref{tab:graph_element_functions}.

\subsubsection{Global access for individual node/edge attributes and graph attributes}

\input{Y_graph_attribute_functions}

It is sometimes useful to access or manipulate attributes of nodes and edges
globally.
For example, an algorithm might want to hide node weights entirely
because they are not relevant
or hide them initially and reveal them for individual nodes as
the algorithm progresses.
These functionalities can be accomplished by
\textsf{hideNodeWeights} or \textsf{hideAllNodeWeights}, respectively.
A summary of these capabilities is given in Table~\ref{tab:graph_attribute_functions}.

\subsection{Definition of Functions/Methods}\label{sec:functions}

A programmer can define arbitrary functions (methods) using the construct

\Code{function} \textsl{[return\_type]} \textsl{name} \Code{(}
 \textsl{parameters} \Code{) \{} \\
 \hspace*{3em} \emph{code block} \\
 \Code{\}}

The behavior is like that of a Java method. So, for example,
\begin{verbatim}
function int plus( int a, int b ) {
    return a + b;
}
\end{verbatim}
is equivalent to
\begin{verbatim}
static int plus( int a, int b ) {
    return a + b;
}
\end{verbatim}

The \textsl{return\_type} is optional. If it is missing, the function behaves like
a \textsf{void} method in Java. An example is the recursive function
\Code{visit} in depth-first search.
\\
\Code{function visit( Node v ) \{} \textsl{code} \Code{\}}

\input{Y_data_structures}

\subsection{Data Structures}

Galant provides some standard data structures for nodes and edges automatically.
These are described in detail in Tables~\ref{tab:algorithm_data_structures} and~\ref{tab:graph_data_structures}.
Table~\ref{tab:algorithm_data_structures} gives information about the simpler
structures -- lists, stacks and queues,
while Table~\ref{tab:graph_data_structures} describes the more sophisticated
-- sets and priority queues.

Data structures use object-oriented syntax.
For example, to add a node \Code{v} to a \Code{NodeList} \Code{L},
the appropriate syntax is \Code{L.add(v)}.
Most data structure operations are as efficient as one might expect.
A notable exception is \Code{decreaseKey}
for priority queues.
The operation \Code{pq.decreaseKey(v,k)}
does \Code{pq.remove(v)} followed by \Code{pq.add(v)}.
The new key is implicit -- it is the weight of the element.
In practice, assuming \Code{pq} is a \Code{NodePriorityQueue},
\Code{v} is a \Code{Node}
and \Code{k} is a \Code{Double}, the sequence would be
\begin{verbatim}
     setWeight(v, k);
     pq.decreaseKey(v,k);
\end{verbatim}
which would translate to
\begin{verbatim}
     setWeight(v, k);
     pq.remove(v);
     pq.add(v)
\end{verbatim}
As pointed out earlier,
the weight of a node or edge is used for priority in a priority
queue or for sorting.
The programmer can change this default
as well as the fact that the nodes/edges prioritized by increasing weight
(the priority queue is a min-heap).

The functionality of a priority queue depends on how it is initialized via a
constructor. Taking \Code{EdgePriorityQueue} as an example
(\Code{NodePriorityQueue} is analogous), the standard initialization, one
that defines a min-heap that uses weights as key is\\
\Code{EdgePriorityQueue q = new EdgePriorityQueue()}\\
or the
declaration\\
\Code{EdgePriorityQueue q}\\
could be separate from\\
\Code{q = new EdgePriorityQueue()}\\

Variations on the constructor call (part following \Code{new}) are
\begin{itemize}
\item \Code{EdgePriorityQueue(true)} to create a max-heap based on weights
  (if the argument is \Code{false} the result is a min-heap, the default)
\item \Code{EdgePriorityQueue("attribute")}, where \Code{"attribute"} is a
  numerical attribute of an edge
\item \Code{EdgePriorityQueue("attribute", true)} to create a max-heap with
  the given attribute.
\end{itemize}

\cmt{A workaround to the fact that the "attribute" constructors don't work is
a setAttribute() method}

\subsection{Queries}

An animation program can query the user for various kinds of input.
For example, the \Code{interactive\_dfs} algorithm asks the user to give a
starting node for a (directed) depth-first search and to give another start
node if the search terminates before all nodes are visited. The different
query options are listed in Table~\ref{tab:utility_functions}.

A query statement in an animation program initiates an algorithm step
unconditionally, i.e., even if it occurs within a
\Code{beginStep}-\Code{endStep} pair.
After the user responds to the query she has to do another step forward
before the animation proceeds (except in case of a Boolean query).
If the user steps backward after responding to a query, the query is not
invoked again. Subsequent forward steps use the same answer.
Thus it is not possible to allow a user to explore multiple alternative
executions in the same run (such a feature would require major enhancements
to the existing implementation).

Queries for nodes and edges ask for node id's (two of them in case of an
edge). Galant checks whether an id is that of a valid node and, in case of an
edge, whether an edge between the two nodes exists. If the graph is currently
directed, the direction of the edge also has to correspond. Any violation
causes an exception to be thrown -- a popup window reports the nature of the
error and allows the user to choose (a) different id(s).
The animator can impose additional restrictions by specifying a set of
permissible nodes/edges (unvisited nodes in the case of
\Code{interactive\_dfs}). If so, the animator also specifies an error message
in case the additional restriction is violated.

Other queries allow an animation to get strings, Boolean values, or numbers
from the user. Examples are in the \Code{binary\_tree} and \Code{grid}
algorithms which create complete binary trees or grid graphs based on tree
height or grid dimensions, respectively, specified as integers by the user.
These queries work the same way as those for vertices and edges. In case of
numbers Galant checks whether the input string is a valid integer or
floating point number and reports an error otherwise.

Boolean queries are a special case. The user does not type a response. The
only options are to press one of two buttons with the mouse or to press the
\Code{Enter} key to specify the default answer (true).
The animator can specify the text displayed on the buttons; defaults are
\Code{"yes"} and \Code{"no"}.
Another difference with Boolean queries is that the algorithm steps forward
immediately when the user responds to the query.\footnote{The reason this is
  not the case with other queries is that errors may need to be handled
  before the algorithm can proceed. Synchronization between the query and the
  algorithm is not straightforward.}

\subsection{Exceptions: Compile and Runtime Errors}

\input{Y-galant_exceptions}

Errors can occur at compile time, either because a macro is malformed or
because the Java code, after macro translation, has errors.
The reporting of Java compiler errors is straightforward. They are reported,
with line numbers, on the console. The line numbers correspond to those in
the Java code listing that also appears on the console (even if there are no
errors). In almost all cases the line numbers also correspond to those of the
original algorithm (before macro translation) in the text
window.\footnote{The only known exception is a function definition where the
  parameters are placed on multiple lines.}

Errors due to malformed macros are not, unfortunately, reported with line
numbers. To make matters worse, unbalanced parentheses or braces inside a
function definition or one of the \Code{for\_\ldots} macros result in a
malformed macro exception. The best strategy is to use a program editor that
does automatic indentation.

Runtime errors are also reported with (almost always correct) line
numbers. Galant makes every effort to catch errors before they result in, for
example, null pointer exceptions in the Galant implementation. Every function
with a graph element argument checks that the argument is not null and
reports a \Code{GalantException} if it is.
The second or third line in the stack trace
refers to the point in the algorithm where the exception occurred.
All exceptions, whether those caught as \Code{GalantException}'s with
meaningful messages or those caught in the Galant impemmentation code, result
in a stack trace on the console and a popup window.
The latter allows to user to choose whether to continue, meaning that the
algorithm is terminated and Galant returns to edit mode, or exit from Galant
completely.
Null pointer exceptions can almost always be tracked down by looking for the
first reference to the algorithm in the stack trace, an item of the form\\
\hspace*{4em}\Code{Galant.algorithm.code.compiled.\emph{algorithm\_name}.run(\emph{algorithm\_name}:\emph{line\_number})}

Exceptions can also occur in edit mode: when reading a graph from a
file, when specifying a node or edge after a keyboard shortcut, or when
giving the weight of a node or edge.
A complete list of Galant exceptions is in Table~\ref{tab:galant_exceptions}.

% [Last modified: 2017 01 12 at 19:02:34 GMT]

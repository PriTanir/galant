  A host of algorithm animation programs have been developed over the
  years. Primarily these have been designed for classroom use and involve
  considerable overhead for the animator of the animations (an instructor or
  developer) --- students are passive observers.  We distinguish three
  primary roles: the \emph{observer}, who simply watches an animation; the
  \emph{explorer}, who is able to manipulate problem instances; and the
  \emph{animator}, who designs an animation.  A key feature of Galant\footnote{
    Aside from being an acronym, Galant is a term for a musical style
that featured a return to classical simplicity after the complexity of the late Baroque era. We hope to achieve the same in our approach to algorithm animation.
} is that
  it simplifies the role of the animator so that students can create their
  own animations by adding a few visualization directives to pseudocode-like
  implementations of algorithms.  The focus on graph algorithms has a key
  advantages: the objects manipulated in an animation all have the same
  type.
  The restrictions to graphs need not be a limitation:
  graphs are ubiquitous and Galant therefore provides a framework for
  animations in domains beyond classic graph algorithms; examples include
  search trees, automata, and even sorting.

  Galant is also distinguished in that it is a tool rather than a closed
  system.  In other words, it is designed to interact easily with other
  software such as text editors, other graph editors, other algorithm
  animation tools, graph generators, Java API's, format translation filters
  and graph drawing programs. This interactivity significantly expands the
  range of Galant's applications, including, for example, as a research tool
  for exploring graph algorithms.

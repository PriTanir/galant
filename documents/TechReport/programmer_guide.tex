Animation programmers can write algorithms in notation that resembles
textbook pseudocode.
The animation examples have used procedural syntax for function calls, as in, for example,
\texttt{setWeight(v,0)}.
Java (object oriented) syntax can also be used: \texttt{v.setWeight(0)}.

Central to the Galant API is the \texttt{graph} object: currently all other
parts of the API refer to it.
The components of a graph are declared to be of type \texttt{Node} or
\texttt{Edge} and can be accessed/modified via a variety of
functions/methods.
When an observer or explorer interacts with the animation they move either
forward or backward one step at a time.
All aspects of the graph API therefore refer to the current \emph{state of
  the graph}, the set of states behaving as a stack.
API calls that change the state of a node or an edge automatically
generate a next step,
but the programmer can override this using a \texttt{beginStep()} and
\texttt{endStep()} pair. For example, the beginning of our implementation of
Dijkstra's algorithm looks like
\begin{verbatim}
beginStep();
for_nodes(node) {
    setWeight(node, INFINITY);
    nodePQ.add(node);
}
endStep();
\end{verbatim}
Without the \texttt{beginStep}/\texttt{endStep}
override, this initialization would require the observer to click
through multiple steps (one for each node) before getting to the interesting
part of the animation.

\input{Y_graph_functions}

Functions and macros for the graph as a whole are shown in Table~\ref{tab:graph_functions}.
Also included are a few functions that are global to an algorithm without
any direct connection to a graph.

The nodes and edges, of type \textsf{Node} and \textsf{Edge}, respectively,
are subtypes of \textsf{GraphElement}.
Arbitrary attributes can be assigned to each graph element. In the GraphML file
these show up as, for example,\\
\hspace*{3em}
\textsf{
$<$node \emph{attribute\_1}="\emph{value\_1}" ... \emph{attribute\_k}="\emph{value\_k}" /$>$
}

Each node and edge has a unique integer id.
The id's are assigned consecutively as nodes/edges are created
and may not be altered.
The id of a node or edge can be accessed via the \texttt{id()} function.
Often, as is the case with the depth-first search algorithm, it makes sense to use
arrays indexed by node or edge id's.
Since graphs may be generated externally and/or have undergone deletions of nodes or
edges, the id's are not always contiguous.
The functions \texttt{nodeIds()} and \texttt{edgeIds()} return the size of an array
large enough to accomodate the appropriate id's as indexes. So code such as
\begin{verbatim}
Integer myArray[] = new Integer[nodeIds()];
for_nodes(v) {
    myArray[id(v)] = ...
}
\end{verbatim}
is immune to array out of bounds errors.

\subsection{Node and edge methods}

Nodes and edges have `getters' and `setters' for
a variety of attributes, i.e.,
\\
\texttt{set}$a$\texttt{($\langle a's$ type$\rangle$ x)}
\\
and
\\
$\langle a's$ type$\rangle$ \texttt{get}$a$\texttt{()},
where $a$ is the name of an attribute such as
\texttt{Color},
\texttt{Label} or \texttt{Weight}.
A more convenient way to access these standard attributes omits the prefix \texttt{get}
and uses procedural syntax:
\texttt{color(}$x$\texttt{)} is a synomym for $x$\texttt{.getColor()}, for example.
Procedural syntax for the setters is also available:
\texttt{setColor(}$x$,$c$\texttt{)} is a synonym for $x$.\texttt{setColor(}$c$\texttt{)}.
In the special cases of color and label it is possible to omit the \texttt{set}
(since it reads naturally): \texttt{color(}$x$,$c$\texttt{)} instead of \texttt{setColor(}$x$,$c$\texttt{)}.

\subsubsection*{Logical attributes: functions and macros}

\textbf{Nodes.}
From a node's point of view we would like information about the adjacent nodes and incident edges.
The relevant \emph{methods} require the use of Java generics, but macros are provided
to simplify graph API access. The macros, which have equivalents in GDR, are:

\begin{itemize}

\item
\texttt{for\_adjacent(x, e, y)\{ \emph{statements} \}}
executes the list of statements for each edge incident on \verb$x$.
The statements can refer to \verb$x$, or \verb$e$, the current incident edge,
or \verb$y$, the other endpoint of \verb$e$.
The macro assumes that \texttt{x} has already been declared as \texttt{Node}
but \texttt{e} and \texttt{y} are declared automatically.

\item
\texttt{for\_outgoing(Node x, Edge e, Node y)\{ \emph{statements} \}}\\
behaves like \texttt{for\_adjacent} except that, when the graph is directed,
it iterates only over the edges whose source is \verb$x$ (it still iterates over all the edges when the graph is undirected). 

\item
\texttt{for\_incoming(Node x, Edge e, Node y)\{ \emph{statements} \}}\\
behaves like \texttt{for\_adjacent} except that, when the graph is directed,
it iterates only over the edges whose sink is \verb$x$ (it still iterates over all the edges when the graph is undirected). 

\end{itemize}

The actual API methods hiding behind these macros are (these are Node methods):

\begin{itemize}
\item
\texttt{List<Edge>~getIncidentEdges()} returns a list of all edges incident to this node,
both incoming and outgoing.
\item
\texttt{List<Edge>~getOutgoingEdges()} returns a list of edges directed away
from this node (all incident edges if the graph is undirected).
\item
\texttt{List<Edge>~getIncomingEdges()} returns a list of edges directed toward
this node (all incident edges if the graph is undirected).
\item
\texttt{Node~travel(Edge~e)} returns the other endpoint of \texttt{e}.
\end{itemize}

The above all use Java syntax, as in \texttt{v.travel(e)}.
The following are node-related functions with procedural syntax.

\begin{itemize}
\item \texttt{degree(v)}, \texttt{indegree(v)} and \texttt{outdegree(v)} return the appropriate
integers.
\item \texttt{otherEnd(v, e)}, where \texttt{v} is a node and \texttt{e} is an edge
returns node \texttt{w} such that \texttt{e} connects \texttt{v} and \texttt{w};
the programmer can also say \texttt{otherEnd(e, v)} in case she forgets the order
of the arguments.
\item \texttt{neighbors(v)} returns a list of the nodes adjacent to node \texttt{v}.
\end{itemize}

\bigskip
\textbf{Edges.}
The logical attributes of an edge are its source and target (destination).

\begin{itemize}
\item
\texttt{setSourceNode(Node)} and \texttt{Node~getSourceNode()}
\item
\texttt{setDestNode(Node)} and \texttt{Node~getDestNode()}
\item
\texttt{getOtherEndPoint(Node~u)} returns \texttt{v} where this edge is
either \texttt{uv} or \texttt{vu}.
\end{itemize}

\bigskip
\textbf{Graph Elements.}
Nodes and edges both have a mechanism for setting (and getting)
arbitrary attributes of type Integer, String, and Double.
the relevant methods are\\
\texttt{setIntegerAttribute(String~key,Integer~value)}\\ 
to associate an integer value with a node and\\
\texttt{Integer~getIntegerAttribute(String~key)}\\
to retrieve it.
String and Double attributes work the same way as integer attributes.
These are useful when an algorithm requires arbitrary information to be
associated with nodes and/or edges.
The user-defined attributes may differ from one node or edge to the next.
For example, some nodes may have a \texttt{depth} attribute while others do not.

\subsubsection*{Geometric attributes}

Currently, the only geometric attributes are the positions of the
nodes. 
Unlike GDR, the edges in Galant
are all straight lines and the positions of their labels are fixed.
The relevant methods for nodes -- using procedural syntax -- are
\texttt{int~getX(Node)}, \texttt{int~getY(Node)}
and \texttt{Point~getPosition(Node)}
for the 'getters'. To set a position,
one should use either
\texttt{setPosition(Node,Point)}\\
or \texttt{setPosition(Node,int,int)}.
Once a node has an established position, it is possible to change
only one coordinate using \texttt{setX(Node,int)} or \texttt{setY(Node,int)}.
Object-oriented variants of all of these, e.g.,
\texttt{v.setX(100)}, are also available.

Ordinarily nodes can be moved by the user during algorithm execution
and the resulting positions persist after execution terminates.
For some algorithms, such as sorting, the algorithm itself needs to move
nodes.
It is desirable then to keep the user from moving nodes.
The declaration \texttt{movesNodes()} at the beginning of an algorithm
accomplishes this.

\subsubsection*{Display attributes}

Each node and edge has
both a (double) weight and a label.
The weight
is also a logical
attribute in that
it is used implicitly as a
key for
sorting and priority queues.
The label is simply text and may be interpreted however the programmer
chooses.
Aside from the setters and getters: \texttt{setWeight(double)},
\mbox{\texttt{Double getWeight()}}, \texttt{setLabel(String)}
and \mbox{\texttt{String getLabel()}}, the programmer can also
manipulate and test for the absence of weights/labels using
\texttt{clearWeight()} and \texttt{boolean~hasWeight()},
and the corresponding methods for labels.
The procedural variants in this case are
\texttt{setWeight(Node,double)},
\mbox{\texttt{Double weight(Node)}},\footnote{
  The \emph{get} is omitted here for more natural syntax.}
\texttt{label(Node,String)},\footnote{
  A natural syntax that resembles English. However,
  \texttt{setLabel(Node,String)} is also allowed.
}
and \mbox{\texttt{String label(Node)}}

Nodes can either be plain, highlighted (selected), marked (visited) or both highlighted and
marked.
Being highlighted alters the
the boundary (color and thickness) of a node (as controlled by the
implementation), while being marked affects the fill color.
Edges can be plain or selected, with thickness and color modified in the
latter case.

The relevant methods are
(here \texttt{Element} refers to either a \texttt{Node} or an \texttt{Edge}):
\begin{itemize}
\item \texttt{highlight(Element)}, \texttt{unHighlight(Element)}
  and \texttt{Boolean~isHighlighted(Element)}
\item correspondingly, \texttt{setSelected(true)}, \texttt{setSelected(false)},
and \texttt{boolean~isSelected()}
\item \texttt{mark(Node)}, \texttt{unMark(Node)}
  and \texttt{Boolean~isMarked(Node)},
  equivalently \texttt{Boolean~marked(Node)}.
\end{itemize}

Although the specific colors for displaying selected nodes or edges are
predetermined, the animation implementation can modify the color of a node boundary
or an edge, thus allowing for many different kinds of highlighting.
The \texttt{setColor} and \texttt{getColor} methods use String arguments
using the RGB format \textsf{\#RRGGBB}; for example,
the string \texttt{\#0000ff} is blue.
There are several predefined color constants:

\begin{tabular}{l @{~} l}
\texttt{RED} & \texttt{"\#ff0000"} \\
\texttt{BLUE} & \texttt{"\#00ff00"} \\
\texttt{GREEN} & \texttt{"\#0000ff"} \\
\texttt{YELLOW} & \texttt{"\#ffff00"} \\
\texttt{MAGENTA} & \texttt{"\#ff00ff" } \\
\texttt{CYAN} & \texttt{"\#00ffff"} \\
\texttt{TEAL} & \texttt{"\#009999"} \\
\texttt{VIOLET} & \texttt{"\#9900cc"} \\
\texttt{ORANGE} & \texttt{"\#ff8000"} \\
\texttt{GRAY} & \texttt{"\#808080"} \\
\texttt{BLACK} & \texttt{"\#000000"} \\
\texttt{WHITE} & \texttt{"\#ffffff"}
\end{tabular}

Of the attributes listed above, weight, label, color and position can be
accessed and modified by the user as well as the program.
In all cases, modifications by execution of the animation are ephemeral
-- the graph returns to its original state after execution.

\subsection{Additional programmer information}

A Galant algorithm/program is executed as a method within a Java class.
In order to shield the Galant programmer from Java ideosyncrasies,
some features have been added.

\subsubsection*{Definition of Functions/Methods}

A programmer can define arbitrary functions (methods) using the construct

\texttt{function} \textsl{[return\_type]} \textsl{name} \texttt{(}
 \textsl{parameters} \texttt{) \{} \\
 \hspace*{3em} \textsl{code\_block} \\
 \texttt{\}}

The behavior is like that of a Java method. So, for example,
\begin{verbatim}
function int plus( int a, int b ) {
    return a + b;
}
\end{verbatim}
is equivalent to
\begin{verbatim}
static int plus( int a, int b ) {
    return a + b;
}
\end{verbatim}

The \textsl{return\_type} is optional. If it is missing, the function behaves like
a \textsf{void} method in Java. An example is the recursive
\\
\texttt{function visit( Node v ) \{} \textsl{code} \texttt{\}}
\\
The conversion of functions into Java methods when Galant code is compiled
is complex and may result in indecipherable error messages.

\subsubsection*{Data Structures}

Galant provides some standard data strutures for nodes and edges automatically.
Each of these is supplied as a single instance.
\begin{itemize}

\item
  \texttt{nodeQ} -- a queue of elements of type \texttt{Node}; provides the
  the methods of a Java Queue:
  \begin{itemize}
    \item
      \texttt{offer(n)} -- puts node \verb+n+ on the queue
    \item
      \texttt{poll()} -- returns and removes the node at the front of the queue
    \item
      \texttt{peek()} -- returns the node at the front of the queue but does not remove it
    \item
      \texttt{isEmpty()} -- returns \textsf{true} if the queue is empty
  \end{itemize}

\item
  \texttt{edgeQ} -- a queue of elements of type \texttt{Edge}; methods are
  the same as those for \texttt{nodeQ}

\item
  \texttt{nodeStack} -- a stack of elements of type \texttt{Node}; provides
  methods of a Java Stack:\\
  \texttt{push(Node n)}, \texttt{pop()}, \texttt{peek()}, and \texttt{empty()}

\item
  \texttt{edgeStack} -- a stack of elements of type \texttt{Edge}; same as
  \texttt{nodeStack}

\item
  \texttt{nodePQ} -- a priority queue of elements of type \texttt{Node};
  provides standard priority queue methods:
  \begin{itemize}
    \item
      \texttt{offer(n)} -- puts node \verb+n+ on the priority queue; the priority is defined to be the weight of \verb+n+
    \item
      \texttt{poll()} -- returns and removes the node with the lowest priority
    \item
      \texttt{peek()} -- returns the node with the lowest priority but does not remove it
    \item
      \texttt{isEmpty()} -- returns \textsf{true} if the priority queue is empty
  \end{itemize}
  Unfortunately, the only way to implement the \textsf{decreaseKey} operation
  is to remove and reinsert the node.

  \item
    \texttt{edgePQ} -- analogous to \texttt{nodePQ}

\end{itemize}

Galant also provides classes corresponding to the above instances; these are
\begin{itemize}
  \item \texttt{NodeQueue}
  \item \texttt{EdgeQueue}
  \item \texttt{NodeStack}
  \item \texttt{EdgeStack}
  \item \texttt{NodePriorityQueue}
  \item \texttt{EdgePriorityQueue}
\end{itemize}

\subsubsection*{Global Variables}

One awkward feature of Galant's implementation is that global variables
must be declared \texttt{final}. For arrays and other structures this is not
a problem, except for the annoyance of the syntax. So, for example,
\begin{verbatim}
final int [] theArray = new int[ graph.getNodes.size() ];
\end{verbatim}
will work as expected: the entries of \verb+theArray+ can be modified as the animation progresses.
Not so with scalars. The workaround is along the lines of
\begin{verbatim}
class GlobalVariables {
    public int myInt;
    public double myDouble;
}
final GlobalVariables globals = new GlobalVariables();
\end{verbatim}
and then the globals need to be referred to as \verb+globals.myInt+
and \verb+globals.myDouble+, respectively.

% [Last modified: 2013 07 12 at 20:59:56 GMT]

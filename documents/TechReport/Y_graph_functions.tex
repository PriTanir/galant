\begin{table}
  \small
  \centering
  \begin{tabular}{| m{0.35\textwidth} | m{0.6\textwidth} |}
    \hline
    \shortstack[l]{
      \textsf{List$\langle$Node$\rangle$ getNodes()}\\
      \textsf{NodeList getNodes()}
    }
    &
    returns a list of the nodes of the graph; type \textsf{NodeList}
    is built into Galant
    and essentially equivalent to the Java \textsf{List$\langle$Node$\rangle$};
    see Table~\ref{tab:data_structures}
    \\ \hline
    \shortstack[l]{
      \textsf{List$\langle$Edge$\rangle$ edges()}\\
      \textsf{EdgeList edges()}
    }
    &
    returns a list of edges of the graph; return type
    \textsf{EdgeList} is analogous to \textsf{NodeList}
    \\ \hline
    \textsf{for\_nodes(v) \{
      \emph{statement; \ldots}
      \}}
    &
    \shortstack[l]{
      equivalent to
      \textsf{for ( Node v : nodes() ) \{ \emph{statement; \ldots} \}};\\
      the statements are executed for each node \textsf{v}
    }
    \\ \hline
    \textsf{for\_edges(e)  \{ \emph{statement; \ldots} \}}
    &
    analogous to \textsf{for\_nodes}
    \\ \hline
    \textsf{Integer numberOfNodes()}
    &
    returns the number of nodes
    \\ \hline
    \textsf{Integer numberOfEdges()}
    &
    returns the number of edges
    \\ \hline
    \textsf{int~id(Node~v)}, \textsf{int~id(Edge e)}
    &
    returns the unique identifier of \textsf{v} or \textsf{e}
    \\ \hline
    \textsf{int~nodeIds()}, \textsf{int~edgeIds()}
    &
    returns the largest node/edge identifier plus one;
    useful when an array is to be indexed using node/edge identifiers,
    since these are not necessarily contiguous
    \\ \hline
    \textsf{source(Edge e)}, \textsf{target(Edge e)}
    &
    returns the source/target of edge \textsf{e}, sometimes called the (arrow)
    tail/head or source/destination
    \\ \hline
    \shortstack[l]{
      \textsf{Integer degree(Node v)}\\
      \textsf{Integer indegree(Node v)}\\
      \textsf{Integer outdegree(Node v)}
    }
    &
    the number of edges incident on \textsf{v}, total, incoming and outgoing;
    if the graph is undirected, the outdegree is the same as the degree
    \\ \hline
    \shortstack[l]{
      \textsf{EdgeList edges(Node v)}\\
      \textsf{EdgeList inEdges(Node v)}\\
      \textsf{EdgeList outEdges(Node v)}
    }
    &
    returns a list of \textsf{v}'s
    indicent, incoming or outgoing edges, respectively;
    outgoing edges are the same as incident edges if the graph is undirected 
    \\ \hline
    \shortstack[l]{
      \textsf{Node otherEnd(Edge e, Node v)}\\
      \textsf{Node otherEnd(Node v, Edge e)}
    }
    &
    returns the node opposite \textsf{v} on edge \textsf{e};
    if \textsf{v} is the source \textsf{otherEnd} returns the target and
    vice-versa
    \\ \hline
    \textsf{NodeList neighbors(Node v)}
    &
    returns a list of nodes adjacent to \textsf{v}
    \\ \hline
    \shortstack[l]{
      \textsf{for\_adjacent(v, e, w) \{ \emph{code block} \}} \\
      \textsf{for\_incoming(v, e, w) \{ \emph{code block} \}} \\ 
      \textsf{for\_outgoing(v, e, w) \{ \emph{code block} \}}
    }
    &
    \textsf{for\_adjacent} executes the code block for each edge \textsf{e}
    incident on \textsf{v}, where \textsf{w} is \textsf{otherEnd(e,v)};
    \textsf{v} must already be declared but \textsf{e} and \textsf{w} are
    declared by the macro;
    the other two are analogous for incoming and outgoing edges 
    \\ \hline
    \textsf{getStartNode()}
    &
    returns the first node in the list of nodes, typically the one with smallest id;
    used by algorithms that require a start node
    \\ \hline
    \textsf{isDirected()}
    &
    returns true if the graph is directed
    \\ \hline
    \textsf{setDirected(boolean directed)}
    &
    makes the graph directed or undirected depending on whether \texttt{directed}
    is true or false, respectively
    \\ \hline
    \shortstack[l]{
      \textsf{Node addNode()}\\
      \textsf{Node addNode(Integer x, Integer y)}
    }
    &
    returns a new node and adds it to the list of nodes;
    the id is the smallest integer not currently in use as an id;
    attributes such as weight, label and position are absent and must be set explicitly
    by appropriate method calls;
    the second version sets the position of the node at \textsf{(x,y)}
    \\ \hline
    \shortstack[l]{
      \textsf{addEdge(Node source, Node target)}\\
      \textsf{addEdge(int sourceId, int targetId)}
    }
    &
    adds an edge from the source to
    the target (source and target are interchangeable when graph is undirected);
    the second variation specifies id's of the nodes to be connected;
    as in the case of adding a node, the edge is added to the list of edges and
    its weight and label are absent
    \\ \hline
    \textsf{deleteNode(Node v)}
    &
    removes node \textsf{v} and its incident edges from the graph
    \\ \hline
    \textsf{deleteEdge(Edge e)}
    &
    removes edge \textsf{e} from the graph
    \\ \hline
  \end{tabular}
  \caption{Functions and macros that apply to the structure of a graph.}
  \label{tab:graph_functions}
\end{table}

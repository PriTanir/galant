\section{Background}\label{sec:background}

Algorithm animation has a long history, dating back at least as far as the
work of Brown and Sedgewick~\cite{1985-IEEE_Software-Brown,1988-Computer-Brown} and that of Bentley and Kernighan~\cite{1987-Animation-Bentley} in the 1980's.
The BALSA software, developed by Brown and Sedgewick, was a sophisticated system and provided several
elaborate examples of animations, including various balanced search trees,
Huffman trees, depth-first search, Dijkstra's algorithm and transitive closure.
The Bentley-Kernighan approach is simple but, as we shall see, has some similarity with that
of Galant: An implementation of an algorithm is annotated with output directives that trace its execution.
These directives are later processed by an interpreter that
converts each directive into a still picture (or modification of a previous
picture).

We distinguish between an animation \emph{tool}
and an animation \emph{system}.
A tool can function in concert with other programs to produce
alternate animations, to create drawings, to obtain input generated by other
programs (such as random graph generators or external graph editors) and to
edit animation programs.
An animation system is
self-contained and uses external software in the form of libraries, if at all.
BALSA is, by our definition, a system while the Bentley-Kernighan approach is a classic example of a tool, following the
Unix philosophy:
any piece of software can be used to provide the stream of (text) directives and any
software can be used to interpret that stream;
thus one could simply link (via a Unix pipe) the output of one program
(the program running the algorithm with annotations) to the
input of another (the interpreter of the directives).
Another good example of a tool is John Stasko's SAMBA~\cite{SAMBA}.

We broaden our definition of tool to include software that, while not usable
in the Unix pipeline context, is \emph{specifically designed} to allow manipulation
of key elements by programs independent of the software.
In the context of graph algorithm animation independent programs include,
among others, programs that edit graphs or modify their layout, programs that edit
algorithms or convert algorithms from one format/language to another. 

Other early contributions to algorithm animations include the work of
John Stasko~\cite{1990-Computer-Stasko}, whose Tango system allowed programmers to
develop animations with smooth motion between steps;
and a Marc Brown's PhD dissertation, published as a book~\cite{1988-Animation-Brown}. Brown articulated a sophisticated
architecture for algorithm animation and illustrated it with a working
implementation (a refined version of BALSA).

In discussing specific instances of algorithm animation,
we distinguish three primarily roles: the \emph{observer}, who simply
watches an animation; the \emph{explorer}, who interacts with an animation by,
for example, changing the problem instance; and the \emph{creator}, who
designs an animation. The latter may also be referred to as a
\emph{developer} if the process of creating animations is integrated with
that of implementing the animation system. An explorer is also an observer and a creator is both of
the others.
R\"ossling and Freisleben~\cite{2002-JVLC-Roessling} articulate a similar
classification of roles.

% For later use in a short paper: we have adapted categories articulated by
% R&F as follows:

A hypothesis, at least partially validated (using student attitude
surveys~\cite{1997-SIGCSE-Stasko}) is
\begin{enumerate}
  \item
    The value added --- beyond lectures and textbook
    --- for students watching an animation (observer role)
    is minimal.
  \item
    If students are able to manipulate problem instances (explorer role)
    the gain is more significant.
  \item
    Students who implement algorithms and design simple animations of them
    (creator role) are likely internalize the structure of the algorithm and
    come away with significant understanding of it.
\end{enumerate}

We call animations that are designed for (1) above, i.e., observer focused,
\emph{demonstration} animations;
those designed for (2), i.e., for both observer and explorer, are
\emph{interactive} animations; those designed for (3) are
\emph{creative} animations.
%% An orthogonal category is \emph{single-purpose}, by which we mean that the
%% animation is designed for one specific algorithm.
%% Traditionally, algorithm animation has been used as supplemental material,
%% often single purpose and created either by the instructor using a
%% suitable system or by an external developer.


% [Last modified: 2013 06 26 at 18:44:29 GMT]
